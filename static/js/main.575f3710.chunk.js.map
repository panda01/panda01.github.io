{"version":3,"sources":["Scroller.js","FakeList.js","reportWebVitals.js","index.js"],"names":["Scroller","props","$innerWrapper","React","createRef","$spacer","state","itemsPerPage","startPageIdx","endPageIdx","thresholdMultiplier","handleScrollEvt","bind","evt","innerWrapperRect","this","current","getBoundingClientRect","mainEl","parentElement","distanceToBottom","bottom","clientHeight","isGoingDown","scrollTop","lastScrollTopPos","isCloseToEndOfList","threshold","tooMuchOnTop","Math","abs","top","console","log","maxPages","setState","isTooMuchOnTheBottom","isCloseToTheBegining","currSpacerHeight","buestGuessTotalHeight","numPagesShown","approxHeightPerPage","numTotalPages","children","length","ceil","approxSizeOfWholeList","style","height","prevProps","prevState","oldScrollerHeight","diff","shouldUpdate","startElemIdx","endElemIdx","visibleSubSection","slice","className","onScroll","ref","Component","niceCityList","oldList","newList","idx","Object","keys","forEach","countryName","cityName","push","makeCountryCityListOneDimensional","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","FakeList","document","getElementById"],"mappings":"4SA+HeA,E,kDAzHd,WAAYC,GAAQ,IAAD,8BAClB,cAAMA,IACDC,cAAgBC,IAAMC,YAC3B,EAAKC,QAAUF,IAAMC,YACrB,EAAKE,MAAQ,CACZC,aAAc,IACdC,aAAc,EACdC,WAAY,EACZC,oBAAqB,KAEtB,EAAKC,gBAAkB,EAAKA,gBAAgBC,KAArB,gBAVL,E,mDAYnB,SAAgBC,GACf,IAAMC,EAAmBC,KAAKb,cAAcc,QAAQC,wBAC9CC,EAASH,KAAKb,cAAcc,QAAQG,cAAcA,cAGlDC,EAAmBN,EAAiBO,OAASH,EAAOI,aAGpDC,EAAcL,EAAOM,UAAYT,KAAKU,iBAI5C,GAFAV,KAAKU,iBAAmBP,EAAOM,UAE5BD,EAAa,CACf,IAAMG,EAAqBN,EAAmBL,KAAKY,UAC7CC,EAAeC,KAAKC,IAAIhB,EAAiBiB,KAAOhB,KAAKY,UAC3D,GAAGD,EACFM,QAAQC,IAAI,qDACclB,KAAKT,MAAMG,aAAeM,KAAKmB,UAExDnB,KAAKoB,SAAS,CACb1B,WAAYM,KAAKT,MAAMG,WAAa,SAG7BmB,IACTI,QAAQC,IAAI,sDACZlB,KAAKoB,SAAS,CACb3B,aAAcO,KAAKT,MAAME,aAAe,SAGpC,CACN,IAAM4B,EAAuBhB,EAAmBL,KAAKY,UAC/CU,EAAwBR,KAAKC,IAAIhB,EAAiBiB,KAAOhB,KAAKY,UACpE,GAAGS,EACFJ,QAAQC,IAAI,yDACZlB,KAAKoB,SAAS,CACb1B,WAAYM,KAAKT,MAAMG,WAAa,SAE/B,GAAG4B,EAAsB,CAE/B,GADsD,IAA5BtB,KAAKT,MAAME,aAEpC,OAEDwB,QAAQC,IAAI,kDACZlB,KAAKoB,SAAS,CACb3B,aAAcO,KAAKT,MAAME,aAAe,Q,8BAK5C,WACC,OAAOO,KAAKb,cAAcc,QAAQM,e,+BAEnC,WACCP,KAAKuB,iBAAmB,EACxBvB,KAAKU,iBAAmB,EACxBV,KAAKwB,0B,mCAIN,WACC,IAAMC,EAAgBzB,KAAKT,MAAMG,WAAaM,KAAKT,MAAME,aAEnDiC,EAD4B1B,KAAKb,cAAcc,QAAQM,aACLkB,EAExDzB,KAAKY,UAAYc,EAAsB1B,KAAKT,MAAMI,oBAClD,IAAMgC,EAAgB3B,KAAKd,MAAM0C,SAASC,OAAS7B,KAAKT,MAAMC,aAC9DQ,KAAKmB,SAAWL,KAAKgB,KAAKH,GAC1B,IAAMI,EAAwBJ,EAAgBD,EAC9C1B,KAAKb,cAAcc,QAAQG,cAAc4B,MAAMC,OAASF,EAAwB,O,qCAEjF,SAAwBG,EAAWC,GAClC,OAAOnC,KAAKb,cAAcc,QAAQM,e,gCAEnC,SAAmB2B,EAAWC,EAAWC,GACxC,IACMC,EAAOD,EADapC,KAAKb,cAAcc,QAAQM,aAI/C+B,EAAwB,IAATD,GAAcrC,KAAKT,MAAME,eAAiB0C,EAAU1C,aACzEwB,QAAQC,IAAI,iCAAkCmB,GAC1CC,IAIJtC,KAAKuB,kBAAoBc,EAKzBrC,KAAKV,QAAQW,QAAQ+B,MAAMC,OAASjC,KAAKuB,iBAAmB,Q,oBAE7D,WACC,IAAMgB,EAAevC,KAAKT,MAAME,aAAeO,KAAKT,MAAMC,aACpDgD,EAAaxC,KAAKT,MAAMG,WAAaM,KAAKT,MAAMC,aAChDiD,EAAoBzC,KAAKd,MAAM0C,SAASc,MAAMH,EAAcC,GAClE,OACC,qBAAKG,UAAU,WAAWC,SAAU5C,KAAKJ,gBAAzC,SACC,gCACC,qBAAK+C,UAAU,SAASE,IAAK7C,KAAKV,UAClC,qBAAKqD,UAAU,gBAAgBE,IAAK7C,KAAKb,cAAzC,SACEsD,a,GAjHgBrD,IAAM0D,WCQ7B,IAEeC,EAbf,SAA2CC,GAC1C,IAAMC,EAAU,GACZC,EAAM,EAMV,OALAC,OAAOC,KAAKJ,GAASK,SAAQ,SAASC,GACrCN,EAAQM,GAAaD,SAAQ,SAASE,GACrCN,EAAQO,KAAK,gCAAkBD,EAAlB,KAA8BD,IAApBJ,YAGlBD,EAGaQ,C,MCDNC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCAdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACC,cAAC,EAAD,UACEC,MAGHC,SAASC,eAAe,SAO1Bd,K","file":"static/js/main.575f3710.chunk.js","sourcesContent":["import React from 'react';\nimport './Scroller.css';\nimport { throttle } from 'throttle-debounce';\n\n\nclass Scroller extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.$innerWrapper = React.createRef();\n\t\tthis.$spacer = React.createRef();\n\t\tthis.state = {\n\t\t\titemsPerPage: 500,\n\t\t\tstartPageIdx: 0,\n\t\t\tendPageIdx: 3,\n\t\t\tthresholdMultiplier: 2.1\n\t\t}\n\t\tthis.handleScrollEvt = this.handleScrollEvt.bind(this);\n\t}\n\thandleScrollEvt(evt) {\n\t\tconst innerWrapperRect = this.$innerWrapper.current.getBoundingClientRect();\n\t\tconst mainEl = this.$innerWrapper.current.parentElement.parentElement;\n\n\n\t\tconst distanceToBottom = innerWrapperRect.bottom - mainEl.clientHeight;\n\n\n\t\tconst isGoingDown = mainEl.scrollTop > this.lastScrollTopPos;\n\n\t\tthis.lastScrollTopPos = mainEl.scrollTop;\n\n\t\tif(isGoingDown) {\n\t\t\tconst isCloseToEndOfList = distanceToBottom < this.threshold;\n\t\t\tconst tooMuchOnTop = Math.abs(innerWrapperRect.top) > this.threshold;\n\t\t\tif(isCloseToEndOfList) {\n\t\t\t\tconsole.log('----------------------adding a page to the bottom');\n\t\t\t\tconst isAlreadyAtTheEnd = this.state.endPageIdx === this.maxPages;\n\t\t\t\tif(!isAlreadyAtTheEnd) {\n\t\t\t\t\tthis.setState({\n\t\t\t\t\t\tendPageIdx: this.state.endPageIdx + 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if(tooMuchOnTop) {\n\t\t\t\tconsole.log('----------------------removing a page from the top');\n\t\t\t\tthis.setState({\n\t\t\t\t\tstartPageIdx: this.state.startPageIdx + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst isTooMuchOnTheBottom = distanceToBottom > this.threshold;\n\t\t\tconst isCloseToTheBegining  = Math.abs(innerWrapperRect.top) < this.threshold;\n\t\t\tif(isTooMuchOnTheBottom) {\n\t\t\t\tconsole.log('----------------------removing a page from the bottom');\n\t\t\t\tthis.setState({\n\t\t\t\t\tendPageIdx: this.state.endPageIdx - 1\n\t\t\t\t});\n\t\t\t} else if(isCloseToTheBegining) {\n\t\t\t\tconst isAlreadyAtTheTop = this.state.startPageIdx === 0;\n\t\t\t\tif(isAlreadyAtTheTop) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.log('----------------------adding a page to the top');\n\t\t\t\tthis.setState({\n\t\t\t\t\tstartPageIdx: this.state.startPageIdx - 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tgetWrapperHeight() {\n\t\treturn this.$innerWrapper.current.clientHeight;\n\t}\n\tcomponentDidMount() {\n\t\tthis.currSpacerHeight = 0;\n\t\tthis.lastScrollTopPos = 0;\n\t\tthis.buestGuessTotalHeight();\n\t}\n\t// after things are mounted take the best guess set the height\n\t// so the scrollbar is atleast somewhat accurate\n\tbuestGuessTotalHeight() {\n\t\tconst numPagesShown = this.state.endPageIdx - this.state.startPageIdx;\n\t\tconst currHeightOfElementsShown = this.$innerWrapper.current.clientHeight;\n\t\tconst approxHeightPerPage = currHeightOfElementsShown / numPagesShown;\n\t\t// this will help us in knowing when to add and remove elements\n\t\tthis.threshold = approxHeightPerPage * this.state.thresholdMultiplier;\n\t\tconst numTotalPages = this.props.children.length / this.state.itemsPerPage;\n\t\tthis.maxPages = Math.ceil(numTotalPages);\n\t\tconst approxSizeOfWholeList = numTotalPages * approxHeightPerPage;\n\t\tthis.$innerWrapper.current.parentElement.style.height = approxSizeOfWholeList + 'px';\n\t}\n\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n\t\treturn this.$innerWrapper.current.clientHeight;\n\t}\n\tcomponentDidUpdate(prevProps, prevState, oldScrollerHeight) {\n\t\tconst newScrollerHeight = this.$innerWrapper.current.clientHeight;\n\t\tconst diff = oldScrollerHeight - newScrollerHeight;\n\t\t// if the height of the inner wrapper has changed, and we've changed the start page,\n\t\t// let's update the spacer at the top to accomodate those changes, and save the information\n\t\tconst shouldUpdate = diff !== 0 && this.state.startPageIdx !== prevState.startPageIdx;\n\t\tconsole.log('Diff between oldScrollerHeight', diff);\n\t\tif(!shouldUpdate) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.currSpacerHeight += diff;\n\t\t\n\t\t// FIXME probably an anti pattern with react\n\t\t// should probably be moved to the render.\n\t\t// Have to experiment with that.\n\t\tthis.$spacer.current.style.height = this.currSpacerHeight + 'px';\n\t}\n\trender() {\n\t\tconst startElemIdx = this.state.startPageIdx * this.state.itemsPerPage;\n\t\tconst endElemIdx = this.state.endPageIdx * this.state.itemsPerPage;\n\t\tconst visibleSubSection = this.props.children.slice(startElemIdx, endElemIdx);\n\t\treturn (\n\t\t\t<div className=\"scroller\" onScroll={this.handleScrollEvt}>\n\t\t\t\t<div>\n\t\t\t\t\t<div className=\"spacer\" ref={this.$spacer}></div>\n\t\t\t\t\t<div className=\"inner_wrapper\" ref={this.$innerWrapper}>\n\t\t\t\t\t\t{visibleSubSection}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\nexport default Scroller;\n","import country_city_list from './cities_countries.json'\n\nfunction makeCountryCityListOneDimensional(oldList) {\n\tconst newList = [];\n\tlet idx = 0;\n\tObject.keys(oldList).forEach(function(countryName) {\n\t\toldList[countryName].forEach(function(cityName) {\n\t\t\tnewList.push(<div key={idx++}>{cityName}, {countryName}</div>);\n\t\t});\n\t});\n\treturn newList;\n}\n\nconst niceCityList = makeCountryCityListOneDimensional(country_city_list);\n\nexport default niceCityList;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Scroller from './Scroller';\nimport FakeList from './FakeList';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n\t  <Scroller>\n\t\t  {FakeList}\n\t  </Scroller>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}